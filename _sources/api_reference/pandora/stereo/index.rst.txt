:mod:`pandora.stereo`
=====================

.. py:module:: pandora.stereo


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   census/index.rst
   sad_ssd/index.rst
   stereo/index.rst
   zncc/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   pandora.stereo.AbstractStereo



.. py:class:: AbstractStereo

   Bases: :class:`object`

   .. attribute:: __metaclass__
      

      

   .. attribute:: stereo_methods_avail
      

      

   .. method:: register_subclass(cls, short_name: str, *args)
      :classmethod:

      Allows to register the subclass with its short name

      :param short_name: the subclass to be registered
      :type short_name: string
      :param args: allows to register one plugin that contains different methods


   .. method:: desc(self)
      :abstractmethod:

      Describes the stereo method


   .. method:: compute_cost_volume(self, img_ref: xr.Dataset, img_sec: xr.Dataset, disp_min: int, disp_max: int, **cfg: Union[str, int]) -> xr.Dataset
      :abstractmethod:

      Computes the cost volume for a pair of images

      :param img_ref: reference Dataset image
      :type img_ref:
          xarray.Dataset containing :
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param img_sec: secondary Dataset image
      :type img_sec:
          xarray.Dataset containing :
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param disp_min: minimum disparity
      :type disp_min: int
      :param disp_max: maximum disparity
      :type disp_max: int
      :param cfg: images configuration containing the mask convention : valid_pixels, no_data
      :type cfg: dict
      :return: the cost volume dataset
      :rtype:
          xarray.Dataset, with the data variables:
              - cost_volume 3D xarray.DataArray (row, col, disp)
              - confidence_measure 3D xarray.DataArray (row, col, indicator)


   .. method:: allocate_costvolume(self, img_ref: xr.Dataset, subpix: int, disp_min: int, disp_max: int, window_size: int, metadata: dict, np_data: np.ndarray = None) -> xr.Dataset

      Allocate the cost volume

      :param img_ref: reference Dataset image
      :type img_ref:
          xarray.Dataset containing :
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param subpix: subpixel precision = (1 or 2 or 4)
      :type subpix: int
      :param disp_min: minimum disparity
      :type disp_min: int
      :param disp_max: maximum disparity
      :type disp_max: int
      :param window_size: size of the aggregation window
      :type window_size: int, odd number
      :param metadata: dictionary storing arbitrary metadata
      :type metadata: dictionary
      :param np_data: the arrayâ€™s data
      :type np_data: 3D numpy array, dtype=np.float32
      :return: the dataset cost volume with the cost_volume and the indicator_map
      :rtype:
          xarray.Dataset, with the data variables:
              - cost_volume 3D xarray.DataArray (row, col, disp)
              - confidence_measure 3D xarray.DataArray (row, col, indicator)


   .. method:: point_interval(self, img_ref: xr.Dataset, img_sec: xr.Dataset, disp: float) -> Tuple[Tuple[int, int], Tuple[int, int]]

      Computes the range of points over which the similarity measure will be applied

      :param img_ref: reference Dataset image
      :type img_ref:
          xarray.Dataset containing :
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param img_sec: secondary Dataset image
      :type img_sec:
           xarray.Dataset containing :
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param disp: current disparity
      :type disp: float
      :return: the range of the reference and secondary image over which the similarity measure will be applied
      :rtype: tuple


   .. method:: masks_dilatation(self, img_ref: xr.Dataset, img_sec: xr.Dataset, offset_row_col: int, window_size: int, subp: int, cfg: Union[str, int]) -> Tuple[xr.DataArray, List[xr.DataArray]]

      Return the reference and secondary mask with the convention :
          - Invalid pixels are nan
          - No_data pixels are nan
          - Valid pixels are 0

      Apply dilation on no_data : if a pixel contains a no_data in its aggregation window, then the central pixel
      becomes no_data

      :param img_ref: reference Dataset image
      :type img_ref:
          xarray.Dataset containing :
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param img_sec: secondary Dataset image
      :type img_sec:
          xarray.Dataset containing :
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param offset_row_col: offset
      :type offset_row_col: int
      :param window_size: window size of the measure
      :type window_size: int
      :param subp: subpixel precision = (1 or 2 or 4)
      :type subp: int
      :param cfg: images configuration containing the mask convention : valid_pixels, no_data
      :type cfg: dict
      :return: the reference mask and the secondary masks
      :rtype:
          tuple (reference mask, list[secondary mask, secondary mask shifted by 0.5])
              - reference mask :  xarray.DataArray msk 2D(row, col)
              - secondary mask :  xarray.DataArray msk 2D(row, col)
              - secondary mask shifted :  xarray.DataArray msk 2D(row, shifted col by 0.5)



