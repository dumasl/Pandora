:mod:`pandora.refinement.refinement`
====================================

.. py:module:: pandora.refinement.refinement

.. autoapi-nested-parse::

   This module contains classes and functions associated to the subpixel refinement step.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pandora.refinement.refinement.AbstractRefinement
   pandora.refinement.refinement.NoneRefinement



.. py:class:: AbstractRefinement

   Bases: :class:`object`

   .. attribute:: __metaclass__
      

      

   .. attribute:: subpixel_methods_avail
      

      

   .. method:: register_subclass(cls, short_name: str)
      :classmethod:

      Allows to register the subclass with its short name

      :param short_name: the subclass to be registered
      :type short_name: string


   .. method:: desc(self)
      :abstractmethod:

      Describes the subpixel method


   .. method:: subpixel_refinement(self, cv: xr.Dataset, disp: xr.Dataset, img_ref: xr.Dataset = None, img_sec: xr.Dataset = None) -> Tuple[xr.Dataset, xr.Dataset]
      :abstractmethod:

      Subpixel refinement of disparities and costs.

      :param cv: the cost volume dataset
      :type cv:
          xarray.Dataset, with the data variables:
              - cost_volume 3D xarray.DataArray (row, col, disp)
              - confidence_measure 3D xarray.DataArray (row, col, indicator)
      :param disp: Dataset
      :type disp: xarray.Dataset with the variables :
          - disparity_map 2D xarray.DataArray (row, col)
          - confidence_measure 3D xarray.DataArray (row, col, indicator)
          - validity_mask 2D xarray.DataArray (row, col)
      :param img_ref: reference Dataset image
      :type img_ref:
          xarray.Dataset containing:
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param img_sec: secondary Dataset image
      :type img_sec:
          xarray.Dataset containing:
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :return:
          cv Dataset with the variables (unchanged):
              - cost_volume 3D xarray.DataArray (row, col, disp)
              - confidence_measure 3D xarray.DataArray (row, col, indicator)
          disp Dataset with the variables:
              - disparity_map 2D xarray.DataArray (row, col) that contains the refined disparities
              - confidence_measure 3D xarray.DataArray (row, col, indicator) (unchanged)
              - validity_mask 2D xarray.DataArray (row, col) with the state of the pixel ( Information:
                  calculations stopped at the pixel step, sub-pixel interpolation did not succeed )
              - interpolated_coeff 2D xarray.DataArray (row, col) that contains the refined cost
      :rtype: tuple(Dataset cv, Dataset disp)


   .. method:: approximate_subpixel_refinement(self, cv_ref: xr.Dataset, disp_sec: xr.Dataset, img_ref: xr.Dataset = None, img_sec: xr.Dataset = None) -> xr.Dataset
      :abstractmethod:

      Subpixel refinement of the secondary disparities map, which was created with the approximate method : a diagonal
      search for the minimum on the reference cost volume

      :param cv_ref: the reference cost volume dataset
      :type cv_ref:
          xarray.Dataset, with the data variables:
              - cost_volume 3D xarray.DataArray (row, col, disp)
              - confidence_measure 3D xarray.DataArray (row, col, indicator)
      :param disp_sec: secondary disparity map
      :type disp_sec: xarray.Dataset with the variables :
          - disparity_map 2D xarray.DataArray (row, col)
          - confidence_measure 3D xarray.DataArray (row, col, indicator)
          - validity_mask 2D xarray.DataArray (row, col)
      :param img_ref: reference Dataset image
      :type img_ref:
          xarray.Dataset containing:
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param img_sec: secondary Dataset image
      :type img_sec:
          xarray.Dataset containing:
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :return:
          disp_sec Dataset with the variables :
              - disparity_map 2D xarray.DataArray (row, col) that contains the refined disparities
              - confidence_measure 3D xarray.DataArray (row, col, indicator) (unchanged)
              - validity_mask 2D xarray.DataArray (row, col) with the value of bit 3 ( Information:
                  calculations stopped at the pixel step, sub-pixel interpolation did not succeed )
              - interpolated_coeff 2D xarray.DataArray (row, col) that contains the refined cost
      :rtype: Dataset


   .. method:: loop_refinement(cv: np.ndarray, disp: np.ndarray, mask: np.ndarray, d_min: int, d_max: int, subpixel: int, measure: str, method: Callable[[np.ndarray, np.ndarray, np.ndarray, np.ndarray, str], Tuple[int, int, int]]) -> Tuple[np.ndarray, np.ndarray, np.ndarray]
      :staticmethod:

      Apply for each pixels the refinement method

      :param cv: cost volume to refine
      :type cv: 3D numpy array (row, col, disp)
      :param disp: disparity map
      :type disp: 2D numpy array (row, col)
      :param mask: validity mask
      :type mask: 2D numpy array (row, col)
      :param d_min: minimal disparity
      :type d_min: int
      :param d_max: maximal disparity
      :type d_max: int
      :param subpixel: subpixel precision used to create the cost volume
      :type subpixel: int ( 1 | 2 | 4 )
      :param measure: the measure used to create the cot volume
      :param measure: string
      :param method: the refinement method
      :param method: function
      :return: the refine coefficient, the refine disparity map, and the validity mask
      :rtype: tuple(2D numpy array (row, col), 2D numpy array (row, col), 2D numpy array (row, col))
       


   .. method:: loop_approximate_refinement(cv: np.ndarray, disp: np.ndarray, mask: np.ndarray, d_min: int, d_max: int, subpixel: int, measure: str, method: Callable[[np.ndarray, np.ndarray, np.ndarray, np.ndarray, str], Tuple[int, int, int]]) -> Tuple[np.ndarray, np.ndarray, np.ndarray]
      :staticmethod:

      Apply for each pixels the refinement method on the secondary disparity map which was created with the approximate
        method : a diagonal search for the minimum on the reference cost volume

      :param cv: the reference cost volume
      :type cv: 3D numpy array (row, col, disp)
      :param disp: secondary disparity map
      :type disp: 2D numpy array (row, col)
      :param mask: secondary validity mask
      :type mask: 2D numpy array (row, col)
      :param d_min: minimal disparity
      :type d_min: int
      :param d_max: maximal disparity
      :type d_max: int
      :param subpixel: subpixel precision used to create the cost volume
      :type subpixel: int ( 1 | 2 | 4 )
      :param measure: the type of measure used to create the cost volume
      :param measure: string = min | max
      :param method: the refinement method
      :param method: function
      :return: the refine coefficient, the refine disparity map, and the validity mask
      :rtype: tuple(2D numpy array (row, col), 2D numpy array (row, col), 2D numpy array (row, col))
       



.. py:class:: NoneRefinement(**cfg: str)

   Bases: :class:`pandora.refinement.refinement.AbstractRefinement`

   Default plugin that does not perform refinement

   .. method:: check_conf(**cfg: str) -> Dict[str, str]
      :staticmethod:

      Add default values to the dictionary if there are missing elements and check if the dictionary is correct

      :param cfg: refinement configuration
      :type cfg: dict
      :return cfg: refinement configuration updated
      :rtype: dict


   .. method:: desc(self)

      Describes the subpixel method


   .. method:: subpixel_refinement(self, cv: xr.Dataset, disp: xr.Dataset, img_ref: xr.Dataset = None, img_sec: xr.Dataset = None) -> Tuple[xr.Dataset, xr.Dataset]

      Returns the cost volume and the disparity map without subpixel refinement

      :param cv: the cost volume dataset
      :type cv:
          xarray.Dataset, with the data variables:
              - cost_volume 3D xarray.DataArray (row, col, disp)
              - confidence_measure 3D xarray.DataArray (row, col, indicator)
      :param disp: Dataset
      :type disp: xarray.Dataset with the variables :
          - disparity_map 2D xarray.DataArray (row, col)
          - confidence_measure 3D xarray.DataArray (row, col, indicator)
          - validity_mask 2D xarray.DataArray (row, col)
      :param img_ref: reference Dataset image
      :type img_ref:
          xarray.Dataset containing:
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param img_sec: secondary Dataset image
      :type img_sec:
          xarray.Dataset containing:
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :return:
          cv Dataset with the variables (unchanged):
              - cost_volume 3D xarray.DataArray (row, col, disp)
              - confidence_measure 3D xarray.DataArray (row, col, indicator)
          disp Dataset with the variables:
              - disparity_map 2D xarray.DataArray (row, col) that contains the refined disparities
              - confidence_measure 3D xarray.DataArray (row, col, indicator) (unchanged)
              - validity_mask 2D xarray.DataArray (row, col) with the state of the pixel ( Information:
                  calculations stopped at the pixel step, sub-pixel interpolation did not succeed )
              - interpolated_coeff 2D xarray.DataArray (row, col) that contains the refined cost
      :rtype: tuple(Dataset cv, Dataset disp)


   .. method:: approximate_subpixel_refinement(self, cv_ref: xr.Dataset, disp_sec: xr.Dataset, img_ref: xr.Dataset = None, img_sec: xr.Dataset = None) -> xr.Dataset

      Returns the secondary disparity map without subpixel refinement

      :param cv_ref: the reference cost volume dataset
      :type cv_ref:
          xarray.Dataset, with the data variables:
              - cost_volume 3D xarray.DataArray (row, col, disp)
              - confidence_measure 3D xarray.DataArray (row, col, indicator)
      :param disp_sec: secondary disparity map
      :type disp_sec: xarray.Dataset with the variables :
          - disparity_map 2D xarray.DataArray (row, col)
          - confidence_measure 3D xarray.DataArray (row, col, indicator)
          - validity_mask 2D xarray.DataArray (row, col)
      :param img_ref: reference Dataset image
      :type img_ref:
          xarray.Dataset containing:
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :param img_sec: secondary Dataset image
      :type img_sec:
          xarray.Dataset containing:
              - im : 2D (row, col) xarray.DataArray
              - msk : 2D (row, col) xarray.DataArray
      :return:
          disp_sec Dataset with the variables :
              - disparity_map 2D xarray.DataArray (row, col) that contains the refined disparities
              - confidence_measure 3D xarray.DataArray (row, col, indicator) (unchanged)
              - validity_mask 2D xarray.DataArray (row, col) with the value of bit 3 ( Information:
                  calculations stopped at the pixel step, sub-pixel interpolation did not succeed )
              - interpolated_coeff 2D xarray.DataArray (row, col) that contains the refined cost
      :rtype: Dataset



